Title: "[從.Net工程師的角度來看DevOps 21]Build階段的總結和重構 - Build Server介紹"
Published: 2017-07-30
Modified: 2017-12-12
Image: /posts/migrate/2017-07-30-devopsSeries-refactorScriptAndBuildServerIntro_Asset/image_thumb(22).png
Tags: [".net","visual studio team service","「ithome 第八屆鐵人賽」","devops","powershell","「從.net工程師的角度來看devops」","psake","powershell", "azure-devops"]
RedirectFrom: 2017/07/devopsSeries-refactorScriptAndBuildServerIntro.html
Series: ["「iThome 第八屆鐵人賽」","「從.Net工程師的角度來看DevOps」"]
---
<section><figure><a href="https://lh3.googleusercontent.com/-gYpW8LUpf5w/WX2I6KNMruI/AAAAAAAAWFQ/rZsSO91M1vw57S1SDrHhGSAI7YoZbiKfACHMYCw/s1600-h/image%255B2%255D"><img width="654" height="290" title="image" style="display: inline; background-image: none;" alt="image" src="/posts/migrate/2017-07-30-devopsSeries-refactorScriptAndBuildServerIntro_Asset/image_thumb(22).png" border="0" class="img-responsive"></a><figurecaption>圖片來源：https://pixabay.com/en/books-spine-colors-pastel-1099067/ 和 https://blog.xebialabs.com/2016/03/21/essential-devops-terms/</figurecaption></figure></section><section><p>  在上篇<a href="http://blog.alantsai.net/2017/01/devopsSeries-stylecop.html">[iThome第8屆鐵人賽 20]靜態程式碼分析之程式碼風格 - Stylecop</a>介紹完了如何整合stylecop之後，build階段也差不多到了一個階段。   </p><p>  在這個階段裡面，從最基本的編譯、到執行單元測試、到整合程式碼測試的涵蓋率最後整合Code Analysis和stylecop，整個build基本要做的都做了，因此我們要開始進入如何把這個建制整合到builder server來達到CI的效果   </p><p>  在這篇，將會談到：   </p><ol><li>在一次重構和調整script - 以符合上build server執行的時候比較沒有問題</li><li>對build server做個簡單的介紹</li></ol></section>     <div class="bs-callout bs-callout-default">  sample 程式在 <a href="https://github.com/alantsai-samples/devops-psake/releases/tag/sample%2Fchapter21">github devops-psake sample/chapter21</a>   </div><section>   <a name="KMContentPageTopID" id="KMContentPageTopID"></a><div id="divKMOutline" style="border-style: groove none; margin: 10px 0px;"><ul style="margin: 0px 0px 0px 20px;"><li><a style="line-height: 1.6; font-size: 15px;" href="#WizKMOutline_1501398736044432" ;="">重構build scrip</a><br></li><ul style="margin: 0px 0px 0px 30px;"><li><a style="line-height: 1.6; font-size: 15px;" href="#WizKMOutline_1501398736044415" ;="">允許傳入參數的方式決定是否執行Stylecop和Code Analysis</a><br></li><li><a style="line-height: 1.6; font-size: 15px;" href="#WizKMOutline_1501398736044268" ;="">修正script裡面相對路徑是指執行位置而不是相對於檔案本身</a><br></li><li><a style="line-height: 1.6; font-size: 15px;" href="#WizKMOutline_1501398736044462" ;="">整合psake module - 直接load 整合的psake</a><br></li><li><a style="line-height: 1.6; font-size: 15px;" href="#WizKMOutline_1501398736044815" ;="">整合nuget restore</a><br></li></ul><li><a style="line-height: 1.6; font-size: 15px;" href="#WizKMOutline_1501398736044596" ;="">Build Server的目的和使用</a><br></li><li><a style="line-height: 1.6; font-size: 15px;" href="#WizKMOutline_1501398736044367" ;="">build server工具</a><br></li><li><a style="line-height: 1.6; font-size: 15px;" href="#WizKMOutline_1501398736044257" ;="">免費的build server</a><br></li><li><a style="line-height: 1.6; font-size: 15px;" href="#WizKMOutline_1501398736044895" ;="">結語</a><br></li></ul></div></section>   <a name="more"></a>   <section><h2 id="WizKMOutline_1501398736044432">重構build scrip</h2><p>  在這個階段加入的一些build task會需要在做一點重構方便上build server呼叫，這個部分將對重構內容做說明。   </p><p>  會重構的有：   </p><ul><li>允許傳入參數的方式決定是否執行Stylecop和Code Analysis</li><li>修正script裡面相對路徑是指執行位置而不是<em>相對於檔案本身</em></li><li>整合psake module - 直接load 整合的psake</li><li>整合nuget restore</li></ul><section><h3 id="WizKMOutline_1501398736044415">允許傳入參數的方式決定是否執行Stylecop和Code Analysis</h3><p>   不是每一個專案都會需要執行Stylecop和Code Analysis，因此我們可以調整compile，讓有傳入參數的時候在執行，沒有則不執行。    </p><p>   做法很簡單，就是加2個<code>Properties</code>，代表是否要執行Stylecop和Analysis，如果是<code>false</code>就不執行。    </p><div class="bs-callout bs-callout-default">    相關修改可以直接參考commit：<a href="https://github.com/alantsai-samples/devops-psake/commit/3896aebc743b3cf89901a865e94347fab69c7ad9">調整 - 允許stylecop和condeanalysis透過傳入參數方式決定是否執行</a></div></section><section><h3 id="WizKMOutline_1501398736044268">修正script裡面相對路徑是指執行位置而不是<em>相對於檔案本身</em></h3><p>   在script裡面在執行一些檔案的時候寫了一些相對路徑的語法，舉例來說在<code>build.ps1</code>的<code>.\default.ps1</code>：    </p><pre class="brush: powershell;"><code class="language-powershell line-numbers">    Invoke-psake -buildFile .\default.ps1 -taskList Test `</code></pre><p>   乍看之下，會認為說這個的相對路徑是<em><strong>相對於當前檔案</strong></em>（<code>build.ps1</code>）- 但是其實不是，這個相對路徑是相對於 <em><strong>執行檔案的位置</strong></em>。換句話說指的是呼叫script的位置。    </p><p>   這個會造成很大問題，因為假設你執行的時候和<code>build.ps1</code>是同樣的位置，那麼沒有問題。但是如果假設執行的位置和當前檔案位置不同，那麼整個路徑是錯的。    </p><p>   因此需要調整變成相對於script。    </p><div class="bs-callout bs-callout-info"><p>    關於這個問題，可以參考一些資料：     </p><ol><li><a href="https://weblogs.asp.net/soever/powershell-regerencing-files-relative-to-the-currently-executing-script">PowerShell - referencing files relative to the currently executing script</a></li><li><a href="https://techblog.dorogin.com/powershell-current-directory-relative-to-executing-script-e0647aa6e898">PowerShell: current directory relative to executing script</a></li><li><a href="http://viziblr.com/news/2013/2/17/reliable-path-navigation-in-powershell-based-on-script-locat.html">Reliable Path Navigation in PowerShell based on Script Location</a></li></ol></div><div class="bs-callout bs-callout-default">    相關修改可以直接參考commit：<a href="https://github.com/alantsai-samples/devops-psake/commit/f790b93404849930cc0fe38691648b181b5d2766">[重構]修正取得檔案路徑的方式 - 避免執行script位置不同導致路徑問題</a></div></section><section><h3 id="WizKMOutline_1501398736044462">整合psake module - 直接load 整合的psake</h3><p>   之前psake load進來的版本都是用從nuget package下載下來的版本。在這邊調整為直接load一個準備好的版本。    </p><p>   這麼做的原因只是明確表示，目前使用的psake module版本是幾號（目前是4.6） - 可以增加如果nuget package有提供就用那個版本方便未來直接改版，但是目前沒有加入這個機制。    </p><div class="bs-callout bs-callout-default">    相關修改可以直接參考commit：<a href="https://github.com/alantsai-samples/devops-psake/commit/b0e2c7a5065a7198c1995d008e089378df98f44a">[重構]讓load psake local版本 - 目前是4.6</a></div></section><section><h3 id="WizKMOutline_1501398736044815">整合nuget restore</h3><p>   有很多套件都依賴nuget下載下來，到目前為止都會先透過nuget下載，所以nuget package都有存在因此build都沒有什麼問題。    </p><p>   可是我們不會上<code>packages</code>資料夾，所以假設從github下載repo，其實根本無法build，需要先自己做nuget restore。 </p><p>   因此要在我們的build script裡面加上nuget restore。    </p><p>   和psake module一樣，會把nuget直接整合進來，目前使用的版本是3.5。    </p><p>   restore的方式很簡單，直接呼叫<code>nuget restore $solutionFile</code></p><div class="bs-callout bs-callout-warning"><p>    正常來說應該在<code>default.ps1</code>整合一個task在<code>Init</code>前先做nuget restoer就好，但是由於我們在<code>Properties</code>有一些路勁是從nuget的packages裡面取得（例如<code>$xunitExe</code>），這個會造成一個     執行順序的問題，假設在進入Task前packages還不存在，<code>Properties</code>的對應路徑會不存在，這個有兩個解決方式：     </p><ol><li>在執行到task之前先restore - 因此restore要寫在<code>build.ps1</code></li><li>在default.ps1裡面使用global 參數 - 因此可以讓在執行nuget restore之後把參數的值改掉</li></ol><p>    目前選擇的方式是第二種 - 不選擇第一種的原因是其實要手動先執行nuget restore不直覺     </p></div><div class="bs-callout bs-callout-default">    相關修改可以直接參考commit：<a href="https://github.com/alantsai-samples/devops-psake/commit/798546dbe7738e54cdc1395420f047876eef2b12">加入 nuget restore - nuget版本3.5</a></div></section></section><section><h2 id="WizKMOutline_1501398736044596">Build Server的目的和使用</h2><p>  Build Server講白一點<em>環境</em>和我們開發的機器沒什麼兩樣，他的唯一目的就是用來<strong><em>編譯專案</em></strong>。   </p><p>  那或許會說既然和我們兩樣，那幹嘛還要有build server，直接用我們的機器編譯就好了？原因很簡單，完全是為了節省時間。   </p><p>  以我目前這麼簡單的一個範例專案，光建制和跑測試（不包含stylecop和code Analysis）就要跑將近1分鐘的時間，可以想象如果多人開發，每一次commit我都要在確認目前上面的code是不是建制沒有問題，假設一天有總共20個commit，   我就要<em>浪費&lt;20分鐘</em>的時間（因為build的時候一定影響電腦上執行其他的效能，更別說要pull然後build等其他沒有算進來的時間）   </p><p>  因此我們用Build server做這件事情，只要有commit就自動幫我們建制是否有成功（至少要build成功，test執行成功，甚至如果有需要也可以設定當測試涵蓋率低於某個數字直接報錯）   </p><p>  雖然build server的環境從本質上來說和我們開發的一樣，但是我們開發會自己手動執行做build，但是在build server怎麼自動觸發呢？因此有所謂的build server的軟體可以管理/觸發自動build。   </p><p>  整個搭配起來就是所謂的<strong><em>Continous Integration（CI 持續整合）</em></strong> - 所以build server有時候也稱為CI Server   </p></section><section><h2 id="WizKMOutline_1501398736044367">build server工具</h2><p>  既然了解了什麼是build server之後，就來了解一下如果要建制一個環境需有什麼build的軟體。   </p><p>  基本上來說還蠻多build server的工具，這些工具一般是一個專案會議組設定檔案用來設定如何建制這個專案。一般來說這些工具也提供一些已經寫好的script，讓大家直接連接專案然後非常簡單設定就會自動建制。   </p><p>  直接使用build server提供的script有好有壞，好處是簡單設定，壞處是無法在local跑和build server一樣的動作（因為不知道他的script跑了什麼） - 也是因為這樣所以這個專案的目的就是提供一個通用script能夠在build server跑也能在local跑。   </p><p>  常見的.net build server 有：   </p><ul><li><a href="https://azure.microsoft.com/zh-tw/services/visual-studio-team-services/">TFS (Visual Studio Team Service)</a></li><li>JetBrain的<a href="https://www.jetbrains.com/teamcity/">Teamcity</a></li><li><a href="https://jenkins.io/">Jenkins</a></li></ul><p>  其實還有很多，用自己習慣就好。   </p><div class="bs-callout bs-callout-info">   這也是使用自己build script的好處，因為不會被build server綁死。只要能夠跑powershell都跑得了build script。   </div></section><section><h2 id="WizKMOutline_1501398736044257">免費的build server</h2><p>  雖然上面提到的build server工具有些有免費的可以自己架設在自己的Server，可是自己架設畢竟需要自己管理，並且也要一筆費用（像是機器費用，Server License等），因此如果只是open source專案根本用不起。   </p><p>  因為這些費用的問題，因此以前很難找到給.net免費的CI Server。   </p><p>  幸好目前有非常佛心的服務可以讓我們在open source專案或者提供定量的次數讓我們可以免費使用。   </p><p>  這其中分別有：   </p><ol><li>Visual Studio Team Service - TFS的雲端版本 - 提供每月240分鐘的免費build時間</li><li>Appveyor - 提供open source免費的CI build服務</li></ol></section><section><h2 id="WizKMOutline_1501398736044895">結語</h2><p>  在這篇重新把build script又調整了一下，讓我們上build server的時候執行不會有問題。 </p><p>  快速介紹了build server，和有哪些可以自己架設的build server - 在下一篇將會介紹Appveyor - 如何使用Appveyor來達到我們Open source專案的CI。 </p><div class="wlWriterEditableSmartContent" id="scid:77ECF5F8-D252-44F5-B4EB-D463C5396A79:3d698384-89d3-4802-a7e1-bb1673d70b60" style="margin: 0px; padding: 0px; float: none; display: inline;">標籤: <a href="/tags/devops" rel="tag">devops</a>,<a href="/tags/%e3%80%8ciThome%e7%ac%ac%e5%85%ab%e5%b1%86%e9%90%b5%e4%ba%ba%e8%b3%bd%e3%80%8d" rel="tag">「iThome第八屆鐵人賽」</a>,<a href="/tags/powershell" rel="tag">powershell</a>,<a href="/tags/visual+studio+team+service" rel="tag">visual studio team service</a></div></section>