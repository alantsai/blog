Title: "[iThome第8屆鐵人賽 08]建制結果問題 - 方法2 透過MSBuild的Target"
Published: 2016-12-17
Modified: 2017-12-12
Image: /posts/migrate/2016-12-17-devopsSeries-buildOutputProblem-2_Asset/image_thumb(6).png
Tags: [".net","「ithome 第八屆鐵人賽」","devops","「從.net工程師的角度來看devops」"]
RedirectFrom: 2016/12/devopsSeries-buildOutputProblem-2.html
Series: ["「iThome 第八屆鐵人賽」","「從.Net工程師的角度來看DevOps」"]
---
<div id="divKMOutline" style="border-top-style: groove; border-bottom-style: groove; border-right-style: none; margin: 10px 0px; border-left-style: none"><ul style="margin: 0px 0px 0px 20px"><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1481962983911367" ;="">拆解WebApplication1.csproj</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1481962983911395" ;="">建立console用到的target</a><br><ul style="margin: 0px 0px 0px 30px"><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1481962983911629" ;="">1. target檔案和資料夾名稱參數的產生</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1481962983911738" ;="">2. 註冊執行的動作</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1481962983911828" ;="">3. 是定義執行的動作</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1481962983911688" ;="">4. 把剛剛定義的target放到Console的csproj</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1481962983911793" ;="">5. 執行結果</a><br></li><br></ul></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1481962983911347" ;="">結語</a> </li></ul></div><section> <p>在上篇了解到如果什麼都沒調整的情況下，建制出來的內容會放在一起，根本無法區分哪些內容屬於哪些專案。 </p><p>也提到了.Ner 4.5能夠使用<code>GenerateProjectSpecificOutputFolder</code>，但是假設是.Net 4.5以下呢？ </p><p>這篇我們會沿著這個思路，看看為什麼Asp .Net Mvc專案有個_PublishedWebsite，並且我們是否能夠使用這個資訊來做些處理。 </p><div class="bs-callout bs-callout-default">sample 程式在 github <a href="https://github.com/alantsai-samples/devops-psake/releases/tag/sample%2Fchapter8">devops-psake sample/chapter8</a></div></section><br><a name="more"></a><br><section> <h2 id="WizKMOutline_1481962983911367">拆解WebApplication1.csproj</h2><p>如果我們用editor把web專案的csproj打開，在靠近下面的部分，我們會看到幾個Target </p><figure><a href="https://lh3.googleusercontent.com/-Cjt-QTOBve8/WFT9XRbaBYI/AAAAAAAAVAk/FoniUqLpWX4/s1600-h/image%25255B2%25255D.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="/posts/migrate/2016-12-17-devopsSeries-buildOutputProblem-2_Asset/image_thumb(6).png" width="644" height="46" class="img-responsive"></a><br><figcaption>2個不同的target</figcaption></figure>  <p>一般的Library專案只會有第一個target：<code>Microsoft.CSharp.targets</code>，而Web專案多了一個target：<code>Microsoft.WebApplication.targets</code></p><p>如果把<code>Microsoft.WebApplication.targets</code>打開，我們會看到：有個target叫做：<code>_CopyWebApplicationLegacy</code></p><figure><a href="https://lh3.googleusercontent.com/-h_buNy5Yc8U/WFT9ZN-ltlI/AAAAAAAAVAs/bU1TMxP0lC0/s1600-h/image%25255B5%25255D.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="/posts/migrate/2016-12-17-devopsSeries-buildOutputProblem-2_Asset/image_thumb[1](6).png" width="644" height="206" class="img-responsive"></a><br><figcaption>找到複製的target</figcaption></figure>  <p>這個Target有很多不同檔案類型的判斷，我們可以利用這個作為我們Console複製的target </p></section><section> <h2 id="WizKMOutline_1481962983911395">建立console用到的target</h2><h3 id="WizKMOutline_1481962983911629">1. target檔案和資料夾名稱參數的產生</h3><p>首先在<code>BuildProject</code>建立<code>MSBuildTargets\ApplicationBuild.targets</code>，這個檔案將會是我們target的位置 </p><figure><a href="https://lh3.googleusercontent.com/-9HiExeK1Y3c/WFT9bVwDlkI/AAAAAAAAVA0/H_9Gk4wrL2M/s1600-h/image%25255B8%25255D.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="/posts/migrate/2016-12-17-devopsSeries-buildOutputProblem-2_Asset/image_thumb[2](5).png" width="326" height="338" class="img-responsive"></a><br><figcaption>applicationBuild.targets</figcaption></figure>  <p>在來，我們先定義出要建立的資料夾名稱參數<code>applicationoutputdirectory</code>： </p><pre class="brush: xml;"><code class="language-markup line-numbers"><project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" defaulttargets="Build">
    <propertygroup>
        <applicationoutputdirectory>$(OutDir)_PublishedApplication\$(MSBuildProjectName)
        </applicationoutputdirectory></propertygroup>
    </project></code></pre><h3 id="WizKMOutline_1481962983911738">2. 註冊執行的動作</h3><p>再來，我們會建立當MSBuild執行的時候要執行我們複製的動作 </p><pre class="brush: xml;"><code class="language-markup line-numbers"><project>
...
 <propertygroup><prepareforrundependson>
   $(PrepareForRunDependsOn);
   _CopyApplication
  </prepareforrundependson></propertygroup>
...
</project></code></pre><p>這個意思是，我們會在<code>PrepareForRunDependsOn</code>這個事件插入我們的事件，不過首先要先把之前的執行完，然後在執行我們等一下定義的<code>_CopyApplication</code>這個task </p><h3 id="WizKMOutline_1481962983911828">3. 是定義執行的動作</h3><p>接下來我們可以複製 <code>_CopyWebApplicationLegacy</code>所有的東西，並且做一些調整： </p><ol><li>Name的部分從 _CopyWebApplicationLegacy 改成 _CopyApplication<br></li><li>把路徑 WebProjectOutputDir 改成 ApplicationOutputDirectory<br></li><li>最後，有一組 copy，註解是 <code>&lt;!-- Copy content files recursively to _PublishedWebsites\app\ folder --&gt;</code>也拿掉<br><br></li><br></ol><h3 id="WizKMOutline_1481962983911688">4. 把剛剛定義的target放到Console的csproj</h3><p>把console的csproj打開，然後加入import target的部分在最下面： </p><pre class="brush: xml;"><code class="language-markup line-numbers"><import project="..\BuildProject\MSBuildTargets\ApplicationBuild.targets"></import></code></pre><figure><a href="https://lh3.googleusercontent.com/-KQ-w4KAo4Lg/WFT9dkrUeFI/AAAAAAAAVA8/S83dADQYkAY/s1600-h/image%25255B11%25255D.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="/posts/migrate/2016-12-17-devopsSeries-buildOutputProblem-2_Asset/image_thumb[3](5).png" width="644" height="119" class="img-responsive"></a> <figcaption>用VS修改</figcaption></figure>  <h3 id="WizKMOutline_1481962983911793">5. 執行結果</h3><p>最後整個檔案內容是： </p><pre class="brush: xml;"><code class="language-markup line-numbers"><project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" defaulttargets="Build">
  <propertygroup>
  <applicationoutputdirectory>$(OutDir)_PublishedApplication\$(MSBuildProjectName)</applicationoutputdirectory>
 </propertygroup>

 <propertygroup>
  <prepareforrundependson>
   $(PrepareForRunDependsOn);
   _CopyApplication
  </prepareforrundependson>
 </propertygroup>

 <target name="_CopyApplication" condition="'$(OutDir)' != '$(OutputPath)'">
    <!-- Log tasks -->
    <message text="Copying Web Application Project Files for $(MSBuildProjectName)"></message>

    <!-- Create the _PublishedWebsites\app\bin folder -->
    <makedir directories="$(ApplicationOutputDirectory)\bin"></makedir>

    <!-- Copy build outputs to _PublishedWebsites\app\bin folder -->
    <copy sourcefiles="@@(IntermediateAssembly)" destinationfolder="$(ApplicationOutputDirectory)\bin" skipunchangedfiles="true" retries="$(CopyRetryCount)" retrydelaymilliseconds="$(CopyRetryDelayMilliseconds)"></copy>
    <copy sourcefiles="@@(AddModules)" destinationfolder="$(ApplicationOutputDirectory)\bin" skipunchangedfiles="true" retries="$(CopyRetryCount)" retrydelaymilliseconds="$(CopyRetryDelayMilliseconds)"></copy>
    <copy condition="'$(_SGenDllCreated)'=='true'" sourcefiles="$(IntermediateOutputPath)$(_SGenDllName)" destinationfolder="$(ApplicationOutputDirectory)\%(Content.SubFolder)%(Content.RecursiveDir)" skipunchangedfiles="true" retries="$(CopyRetryCount)" retrydelaymilliseconds="$(CopyRetryDelayMilliseconds)"></copy>
    <copy condition="'$(_DebugSymbolsProduced)'=='true'" sourcefiles="$(IntermediateOutputPath)$(TargetName).pdb" destinationfolder="$(ApplicationOutputDirectory)\bin" skipunchangedfiles="true" retries="$(CopyRetryCount)" retrydelaymilliseconds="$(CopyRetryDelayMilliseconds)"></copy>
    <copy condition="'$(_DocumentationFileProduced)'=='true'" sourcefiles="@@(DocFileItem)" destinationfolder="$(ApplicationOutputDirectory)\bin" skipunchangedfiles="true" retries="$(CopyRetryCount)" retrydelaymilliseconds="$(CopyRetryDelayMilliseconds)"></copy>
    <copy sourcefiles="@@(IntermediateSatelliteAssembliesWithTargetPath)" skipunchangedfiles="true" retries="$(CopyRetryCount)" retrydelaymilliseconds="$(CopyRetryDelayMilliseconds)" destinationfiles="@@(IntermediateSatelliteAssembliesWithTargetPath->'$(ApplicationOutputDirectory)\bin\%(Culture)\$(TargetName).resources.dll')"></copy>
    <copy sourcefiles="@@(ReferenceComWrappersToCopyLocal); @@(ResolvedIsolatedComModules); @@(_DeploymentLooseManifestFile); @@(NativeReferenceFile)" destinationfolder="$(ApplicationOutputDirectory)\bin" skipunchangedfiles="true" retries="$(CopyRetryCount)" retrydelaymilliseconds="$(CopyRetryDelayMilliseconds)"></copy>

    <!-- copy any referenced assemblies to _PublishedWebsites\app\bin folder -->
    <copy sourcefiles="@@(ReferenceCopyLocalPaths)" skipunchangedfiles="true" retries="$(CopyRetryCount)" retrydelaymilliseconds="$(CopyRetryDelayMilliseconds)" destinationfiles="@@(ReferenceCopyLocalPaths->'$(ApplicationOutputDirectory)\bin\%(DestinationSubDirectory)%(Filename)%(Extension)')"></copy>

    <!-- Copy items that have been marked to be copied to the bin folder -->
    <copy sourcefiles="@@(_SourceItemsToCopyToOutputDirectory)" destinationfolder="$(ApplicationOutputDirectory)\bin" skipunchangedfiles="true" retries="$(CopyRetryCount)" retrydelaymilliseconds="$(CopyRetryDelayMilliseconds)"></copy>
    <copy sourcefiles="@@(_SourceItemsToCopyToOutputDirectoryAlways)" destinationfolder="$(ApplicationOutputDirectory)\bin" skipunchangedfiles="false" retries="$(CopyRetryCount)" retrydelaymilliseconds="$(CopyRetryDelayMilliseconds)"></copy>


    <!-- Copy items that need to be bin deployed to the bin folder -->
    <copy sourcefiles="@@(_binDeployableAssemblies)" destinationfolder="$(ApplicationOutputDirectory)\bin\%(RecursiveDir)" skipunchangedfiles="true" retries="$(CopyRetryCount)" retrydelaymilliseconds="$(CopyRetryDelayMilliseconds)"></copy>

  </target>
</project></code></pre><figure><a href="https://lh3.googleusercontent.com/-o1xdpYvZoME/WFT9fQRekdI/AAAAAAAAVBE/Wrn4qWHH8II/s1600-h/image%25255B14%25255D.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; background-image: none; border-bottom-width: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; display: inline; padding-right: 0px; border-top-width: 0px" border="0" alt="image" src="/posts/migrate/2016-12-17-devopsSeries-buildOutputProblem-2_Asset/image_thumb[4](4).png" width="443" height="347" class="img-responsive"></a> <figcaption>執行結果多了一個發佈的資料夾</figcaption></figure>  <div class="bs-callout bs-callout-info">其實第5步的複製有些東西是可以調整更符合console專案，但是這就留給讀者去嘗試 </div><div class="bs-callout bs-callout-info">透過這次修改MSBuild相信對於為什麼不直接用MSBuild而是用Psake有所了解，看MSBuild真的太不容易 </div><section> <h2 id="WizKMOutline_1481962983911347">結語</h2><p>這篇算是比較快速帶過，如何利用MSBuild來做到一些我們想要擴充的動作，在非.Net 4.5之前，這個是我們唯一的做法，不過相較於上一篇提到的方式，這個方法實在太繁瑣了。 </p><p>在接下來的篇章，我會持續使用上篇的做法，並且我們開始要進入到執行測試的階段，不過在進入測試之前，還有一個問題要先解決，那就是當建制失敗應該會怎麼樣。 </p></section></section>