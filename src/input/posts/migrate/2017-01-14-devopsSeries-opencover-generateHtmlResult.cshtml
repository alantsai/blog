Title: "[iThome第8屆鐵人賽 18]OpenCover 結果 - html結果產生篇"
Published: 2017-01-14
Modified: 2017-12-12
Image: /posts/migrate/2017-01-14-devopsSeries-opencover-generateHtmlResult_Asset/image_thumb(14).png
Tags: [".net","「ithome 第八屆鐵人賽」","devops","「從.net工程師的角度來看devops」"]
RedirectFrom: 2017/01/devopsSeries-opencover-generateHtmlResult.html
Series: ["「iThome 第八屆鐵人賽」","「從.Net工程師的角度來看DevOps」"]
---
<section> <p>在上篇了解到了測試涵蓋率的計算方式之後，已經可以了解xml報告的一些數字所代表的意思。 </p><p>但是，xml畢竟不是那麼容易讀得懂，並且也不容易看出到底那些地方沒有測試到。 </p><p>在這篇，將會介紹如何把xml結果產生出html結果，並且如何使用。 </p><div class="bs-callout bs-callout-default">sample 程式在 <a href="https://github.com/alantsai-samples/devops-psake/releases/tag/sample%2Fchapter18">github devops-psake sample/chapter18</a></div></section><section><a id="KMContentPageTopID" name="KMContentPageTopID"></a> <div id="divKMOutline" style="border-top-style: groove; border-bottom-style: groove; border-right-style: none; margin: 10px 0px; border-left-style: none"><ul style="margin: 0px 0px 0px 20px"><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484389680753491" ;="">ReportGenerator - html結果產生工具</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484389680753128" ;="">build script調整</a><br><ul style="margin: 0px 0px 0px 30px"><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484389680753186" ;="">安裝ReportGenerator</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484389680753602" ;="">在測試執行完成產生html結果</a></li><br></ul></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484389680753235" ;="">html結果介紹</a><br><ul style="margin: 0px 0px 0px 30px"><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484389680753932" ;="">結果總覽</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484389680753619" ;="">Assembly執行結果</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484389680753630" ;="">Assembly詳細</a></li><br></ul></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484389680753794" ;="">其他呈現方式</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484389680753778" ;="">結語</a></li><br></ul></div></section> <a name="more"></a><section> <h2 id="WizKMOutline_1484389680753491">ReportGenerator - html結果產生工具</h2><div class="bs-callout bs-callout-info"><h4 id="WizKMOutline_1484389680753541">ReportGerator</h4><p>能夠把多種coverage工具的xml結果產生html格式，其中就有包括open cover的格式 </p><ul><li>Nuget - <a href="https://www.nuget.org/packages/ReportGenerator/">https://www.nuget.org/packages/ReportGenerator/</a><br></li><li>Nuget 安裝指令 - <kbd>Install-Package ReportGenerator</kbd><br></li><li>Github - <a href="https://github.com/danielpalme/ReportGenerator">https://github.com/danielpalme/ReportGenerator</a></li><br></ul></div></section><section> <h2 id="WizKMOutline_1484389680753128">build script調整</h2><p>基本上有以下幾個地方要調整： </p><ol><li>把ReportGenerator安裝到build專案<br></li><li>在測試執行完的時候產生結果</li><br></ol><h3 id="WizKMOutline_1484389680753186">安裝ReportGenerator</h3><p>透過nuget先安裝ReportGenerator，再來在<code>default.ps1</code>裡面，建立一個property是代表reportGenerator的工具： </p><pre class="brush: powershell;"><code class="language-powershell line-numbers">Properties{
....
$reportGeneratorExe = (Get-PackagePath $packageDirectoryPath "ReportGenerator") +
   "\tools\ReportGenerator.exe"
....
}  
  </code></pre><h3 id="WizKMOutline_1484389680753602">在測試執行完成產生html結果</h3><p>再來，有一個<code>Test</code>的task，這個task其實是在3個測試framework執行完才會執行。 </p><p>因此可以在這邊多一個判斷，如果有產生出Coverage的xml的時候，在執行ReportGenerator。 </p><p>這個Generator執行起來很容易，只需要傳入兩個參數： </p><ul><li>openCover xml結果的路徑<br></li><li>產生的html要放的路徑</li><br></ul><p>因此整個task變成： </p><pre class="brush: powershell;"><code class="language-powershell line-numbers">task Test -depends Compile, Clean, XunitTest, NunitTest, MSTest -description "執行Test" { 
 
 if(Test-Path $openCoverResult){
  Write-Host "`r`n產生測試涵蓋率報告 html 格式"
  exec{ &amp;$reportGeneratorExe $openCoverResult $buildTestCoverageDirectory}
 } else {
  Write-Host "`r`n沒有產生測試涵蓋率報告"
 }

 Write-Host $testMsg
}</code></pre></section><section> <h2 id="WizKMOutline_1484389680753235">html結果介紹</h2><p>當在執行build的時候，會在<code>.\testCoverage</code>裡面多出很多檔案，其中最重要的檔案就是<code>Index.htm</code></p><p>如果把Index.htm執行起來，可以看到結果的總覽。 </p><h3 id="WizKMOutline_1484389680753932">結果總覽</h3><p>在index.htm的上半部，是整個結果的總覽。其中有個部分要注意的是，裡面用了<code>Line Coverage</code>這個詞，但是其實這邊指的是<code>Sequence Point Coverage</code>（在報告其他地方也是同理） </p><figure><a href="https://lh3.googleusercontent.com/-4WLlQKidvbY/WHn-JV2RG5I/AAAAAAAAVIw/zMu0MD2vM34/s1600-h/image%25255B2%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="/posts/migrate/2017-01-14-devopsSeries-opencover-generateHtmlResult_Asset/image_thumb(14).png" width="644" height="178" class="img-responsive"></a><figcaption>可以看到整個測試涵蓋率</figcaption></figure> <h3 id="WizKMOutline_1484389680753619">Assembly執行結果</h3><p>在Index.htm的下面則是Assembly執行的總覽，可以簡單看到那些涵蓋率是多少。 </p><p>這邊有幾個可以使用的地方： </p><ol><li>Grouping - 可以切換如何group結果，只要用左右拖拉即可<br></li><li>排序 - 每一個表頭的三角形可以點做排序<br></li><li>Filter - 可以過濾要看哪一個</li><br></ol><figure><a href="https://lh3.googleusercontent.com/-jrJaI5Gt9K4/WHn-LNCJ-jI/AAAAAAAAVI4/bDehJyMtQ7Y/s1600-h/image%25255B5%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="/posts/migrate/2017-01-14-devopsSeries-opencover-generateHtmlResult_Asset/image_thumb[1](13).png" width="644" height="233" class="img-responsive"></a><figcaption>Assembly總覽</figcaption></figure> <h3 id="WizKMOutline_1484389680753630">Assembly詳細</h3><p>如果選一個assembly，可以點進去看到底那邊有cover到，那邊沒有。 </p><p>下面的例子是我們唯一有寫測試的地方，這個報告還會highlight出，那邊是測試點。如果沒涵蓋，會用紅色標註 </p><figure><a href="https://lh3.googleusercontent.com/-9prErRlDGV8/WHn-NbYXMBI/AAAAAAAAVJA/x1i6S1w5-y8/s1600-h/image%25255B8%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="/posts/migrate/2017-01-14-devopsSeries-opencover-generateHtmlResult_Asset/image_thumb[2](7).png" width="644" height="444" class="img-responsive"></a><figcaption>Assembly詳細</figcaption></figure></section><section> <h2 id="WizKMOutline_1484389680753794">其他呈現方式</h2><p>ReportGenerator產生的html其實非常詳細，用來看結果其實非常容易發現沒測試到的地方。 </p><p>不過或許會好奇還有沒有其他使用OpenCover的xml結果的方式，其實還有兩個地方： </p><ol><li><a href="https://coveralls.io/">Coveralls</a> - 如果有希望在網路上給大家看到測試涵蓋率，可以使用Coveralls這個網站服務 - 可以把這個整合到build script裡面，自動把結果發佈到上面<br></li><li><a href="https://marketplace.visualstudio.com/items?itemName=jamdagni86.OpenCoverUI">OpenCover UI - VS 套件</a> - 這個是開發的時候可以使用的，能夠在VS工具裡面直接看到那段程式碼有沒有涵蓋，類似於VS 高版本裡面的Coverage工具呈現的樣子。 </li><br></ol></section><section> <h2 id="WizKMOutline_1484389680753778">結語</h2><p>透過這篇，對於測試涵蓋率和測試碼品質如何保證有個概念。 </p><p>接下來會來看看另外一個角度來保證程式碼品質，也就是透過程式碼分析的方式來達到。 </p></section>