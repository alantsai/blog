Title: "[iThome第8屆鐵人賽 04]開始了解如何使用psake"
Published: 2016-12-04
Modified: 2017-12-12
Image: /posts/migrate/2016-12-04-devopsSeries-psakeIntro_Asset/image_thumb(2).png
Tags: [".net","「ithome 第八屆鐵人賽」","devops","「從.net工程師的角度來看devops」","psake","powershell"]
RedirectFrom: 2016/12/devopsSeries-psakeIntro.html
Series: ["「iThome 第八屆鐵人賽」","「從.Net工程師的角度來看DevOps」"]
---
<a id="KMContentPageTopID" name="KMContentPageTopID"></a> <div id="divKMOutline" style="border-top-style: groove; border-bottom-style: groove; border-right-style: none; margin: 10px 0px; border-left-style: none"><ul style="margin: 0px 0px 0px 20px"><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522479" ;="">開始使用psake</a><br><ul style="margin: 0px 0px 0px 30px"><ul style="margin: 0px 0px 0px 30px"><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522660" ;="">psake基本資訊</a></li></ul></ul></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522754" ;="">準備好測試專案</a><br><ul style="margin: 0px 0px 0px 30px"><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522244" ;="">第一步 - 建立C# Library Project和安裝psake nuget</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522752" ;="">第二步 - 產生default.ps1檔案</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522669" ;="">第三步 - 執行我們定義的Task</a></li><br></ul></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522456" ;="">介紹psake的task寫法</a><br><ul style="margin: 0px 0px 0px 30px"><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522488" ;="">檔案default.ps1</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522342" ;="">task的定義</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522654" ;="">task其他參數</a> <ul style="margin: 0px 0px 0px 30px"><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522186" ;="">預設Task</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522889" ;="">增加Task的描述</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522497" ;="">Task參數化</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522132" ;="">在執行Task之前先檢查是否有提供某個參數</a></li><br></ul></li></ul></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522312" ;="">增加方便執行psake的build.ps1檔案</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1480857627522997" ;="">結語</a></li><br></ul></div><section> <p>在上一篇了解了如何建制一個專案之後，和我們之後要使用psake作為build tool，在這篇我們將會看到底怎麼開始使用psake，和建立出我們之後會一直使用的專案。 </p><p>（之後下面提到的code都可以從這邊看到內容：<a href="https://github.com/alantsai-samples/devops-psake/tree/master">github repo</a>，這篇會是tag <code>sample/chapter4</code>） </p></section> <a name="more"></a><section> <h2 id="WizKMOutline_1480857627522479">開始使用psake</h2><p>psake是一個powershell的module，因此，除了psake的module檔案需要下載之外，在Windows不需要在做什麼其他安裝和設定。 </p><p>安裝psake到電腦裡面其實很簡單，只需要到psake的github repo下載下來，然後在powershell裡面呼叫<code>Import-Module .\psake.psm1</code>，那麼psake就好了。 </p><p>當然，還需要這個下載動作好麻煩，從專案角度來說，難道我需要要求所有開發者都需要自己做這件事情嗎？那不是很麻煩 </p><p>非常好的是，psake有提供nuget版本，因此我們可以用nuget來把psake鍵入到專案裡面（如果想裝在電腦裡，可以透過chocolatey來方便安裝） </p><div class="bs-callout bs-callout-info"><h4 id="WizKMOutline_1480857627522660">psake基本資訊</h4><ul><li>psake github repo：<a href="https://github.com/psake/psake">https://github.com/psake/psake</a><br></li><li>nuget：<a href="https://www.nuget.org/packages/psake/">https://www.nuget.org/packages/psake/</a><br></li><li>nuget 安裝指令：<kbd>Install-Package psake</kbd><br></li><li>說明文件：<a href="http://psake.readthedocs.io/en/latest/">http://psake.readthedocs.io/en/latest/</a><br></li><li>chocolatey：<a href="https://chocolatey.org/packages/psake">https://chocolatey.org/packages/psake</a><br></li><li>chocolatey指令：<kbd>choco install psake</kbd></li><br></ul></div><p>了解基本資訊之後，我們就開始建立測試環境 </p></section><section> <h2 id="WizKMOutline_1480857627522754">準備好測試專案</h2><p>我們就先建立一個Visual Studio的專案。以前，nuget是可以安裝在solution層級，但是後來改掉了，但是問題不大，我們可以建立一個C# Library用來記錄這個dependency。 </p><div class="bs-callout bs-callout-info"><p>接下來psake相關內容我們寫的其實都是powershell的語法 - 看個人使用，可以用powershell的ise來寫，或者用Visual Studio。 </p><p>既然大家都是開發者，建議用Visual Studio - 可以安裝一個套件<a href="http://adamdriscoll.github.io/poshtools/">PowerShell Tools for Visual Studio</a>， 未來debug什麼都可以直接在Visual studio做。甚至想寫單元測試都可以直接在上面跑。 </p><p>powershell有個好處是，如果到時候到build server有問題，可以用上面的powershell ise來直接debug。 </p></div><h3 id="WizKMOutline_1480857627522244">第一步 - 建立C# Library Project和安裝psake nuget</h3><p>先建立一個C# Library的Project，把預設的Class1.cs刪掉，然後用nuget安裝psake： </p><figure><a href="https://lh3.googleusercontent.com/-la7AqI7GIaA/WEQZXyr9EDI/AAAAAAAAU88/7qivgREurPk/s1600-h/image%25255B2%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="/posts/migrate/2016-12-04-devopsSeries-psakeIntro_Asset/image_thumb(2).png" width="644" height="240" class="img-responsive"></a><figcaption>專案準備</figcaption></figure>  <h3 id="WizKMOutline_1480857627522752">第二步 - 產生default.ps1檔案</h3><p>建立一個檔案，然後把檔名取做<code>default.ps1</code>。（可以在新建檔案選class檔案，然後把檔名改掉）： </p><p>然後我們貼上一下內容在default.ps1裡面： </p><pre class="brush: powershell;"><code class="language-powershell line-numbers">task Test -depends Compile, Clean { 
 Write-Host "Executed Test !"
}

task Compile -depends Clean { 
 Write-Host "Executed Compile !"
}

task Clean { 
 Write-Host "Executed Clean !"
}</code></pre><h3 id="WizKMOutline_1480857627522669">第三步 - 執行我們定義的Task</h3><p>開啟VS 裡面的 <code>Powershell Interactive Windows</code>（可以透過搜索右上角的<code>Quick Launch</code>快速找到） </p><figure><a href="https://lh3.googleusercontent.com/-apoBuQ2fcmQ/WEQZann0VcI/AAAAAAAAU9E/kcD31rpYaxg/s1600-h/image%25255B5%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="/posts/migrate/2016-12-04-devopsSeries-psakeIntro_Asset/image_thumb[1](3).png" width="644" height="354" class="img-responsive"></a><figcaption>Quick Launch</figcaption></figure>  <p>Powershell Interactive Windows打開之後，先注意一下你的位置，記得要先CD進去有sake專案的位置下，然後執行下面語法（建議各位手動輸入，因為會發現很方便有intellisense） </p><figure><a href="https://lh3.googleusercontent.com/-uqKfw_GDIuk/WEQZdYWrdWI/AAAAAAAAU9M/DudvK_44uS4/s1600-h/image%25255B8%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="/posts/migrate/2016-12-04-devopsSeries-psakeIntro_Asset/image_thumb[2](2).png" width="644" height="224" class="img-responsive"></a><figcaption>輸入方法有intellisense</figcaption></figure>   <ol><li><kbd>Import-Module ..\packages\psake.4.6.0\tools\psake.psm1</kbd> - 這個動作是吧psake加入進來<br></li><li><kbd>Invoke-psake Test</kbd> - 執行我們Test的這個Task</li><br></ol>執行下去之後，會看到我們三個Task都執行了，並且我們寫的動作也執行了。 <a href="https://lh3.googleusercontent.com/-GCdd5bZqkZo/WEQZfQiGAPI/AAAAAAAAU9U/HKOp8-WQ22s/s1600-h/image%25255B11%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="/posts/migrate/2016-12-04-devopsSeries-psakeIntro_Asset/image_thumb[3](2).png" width="644" height="331" class="img-responsive"></a><figure><figcaption>可以看到執行了什麼還有總共執行時間 - <em>注意執行的當下資料夾是不是在buildProject</em></figcaption></figure> </section><section> <h2 id="WizKMOutline_1480857627522456">介紹psake的task寫法</h2><p>在這段會介紹剛剛我們準備的時候一些psake相關的資訊，並且在往下做一些延伸。 </p><h3 id="WizKMOutline_1480857627522488">檔案default.ps1</h3><p>首先是檔名的部分。剛剛應該會注意到，執行psake的時候並沒有給他要執行那個檔案，但是他自動找到了。原因是預設他會找<code>default.ps1</code>這個檔案。 </p><p>因此在任何一個psake檔案default.ps1都是進入點。 </p><h3 id="WizKMOutline_1480857627522342">task的定義</h3><p>基本上 task <em>最少（或者最常見）</em> 會定義幾個事情： </p><ol><li>Task的名稱 - 也就是 task 後面的字<br></li><li>Task之間的關聯 - 用 <code>-depends</code>關鍵字 - 可以定義在執行這個Task之前需要先執行什麼Task。如果有多個Task，用逗點(,)區隔。這邊注意一件事情，depend的task <em>最多只會執行一次</em> - 所以，以我們的例子，Test和Compile都相依clean，但是clean只執行了一次。（當然，其實Test不需要寫相依Clean，，因為Compile已經有相依了。<br></li><li>Task要執行什麼 - 這個內容是放在{}裡面。 </li><br></ol><h3 id="WizKMOutline_1480857627522654">task其他參數</h3><h4 id="WizKMOutline_1480857627522186">預設Task</h4><p><em>預設Task的定義</em> - 舉例來說，剛剛執行的時候要輸入Task名稱，但是有一個特殊的task，他的名字叫做 <code>default</code>，這個task只能有<code>-depends</code> 參數，並且沒有執行內容。這個就會是當invoke-psake沒有給task名稱所會執行的。舉例來說：<code>task default -depends Test</code> - 就會定義在 不給task名稱的情況下，預設要執行Test這個task </p><h4 id="WizKMOutline_1480857627522889">增加Task的描述</h4><p><code>-description 參數</code> - 有時候光看Task名稱還不確定會做什麼，所以可以用參數-description給一個詳細說明。這個時候能夠在透過 <code>Invoke-Psake -docs</code>來看到整體的task。 </p><h4 id="WizKMOutline_1480857627522497">Task參數化</h4><p>目前我們在每個task的動作只是寫到console。假設今天我想寫到console的字可以自訂，就會使用到<code>properties</code>，舉例來說，我想定義每一個執行的時候顯示的訊息： 我就會先定義一個properties： </p><pre class="brush: powershell;"><code class="language-powershell line-numbers">Properties{
 $testMsg = "Executed Test !"
 $compileMsg = "Executed Compile !"
 $cleanMsg = "Executed Clean !"
}
  
  </code></pre><p>然後對應的<code>Write-Host</code>改成用這些參數 </p><p>當我要改變這些值的時候，在Invoke-Psake的時候就加上properties就好：<code>Invoke-psake -properties @@{testMsg="測試訊息"}</code></p><figure><a href="https://lh3.googleusercontent.com/-QGvNlKiVm1k/WEQZiW4rSWI/AAAAAAAAU9c/I0Rh-6XzqaI/s1600-h/image%25255B14%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="/posts/migrate/2016-12-04-devopsSeries-psakeIntro_Asset/image_thumb[4](2).png" width="644" height="331" class="img-responsive"></a><figcaption>參數替換</figcaption></figure>  <div class="bs-callout bs-callout-warning"><p>這邊注意到在外面呼叫的時候不需要錢字符（$） </p></div><h4 id="WizKMOutline_1480857627522132">在執行Task之前先檢查是否有提供某個參數</h4><p>如果有些參數會影響到我們執行，可以直接在task裡面用<code>-requiredVariables</code>，然後variable名稱即可。有多個就用逗點分割。 </p><p>這樣可以減少我們需要在執行中做檢測 </p><p>到目前為止有多介紹了一些常用的task定義方式 - 在接下來，如果有些有在額外用到會在用到的時候說明。 </p></section><section> <h2 id="WizKMOutline_1480857627522312">增加方便執行psake的build.ps1檔案</h2><p>在這篇結束以前，我們會發現到每一次執行psake都要先import-module，在執行其實是非常繁瑣，而且如果給另外一個工程師不懂powershell，可能光import module就卡死他了。 </p><p>所以我們會在增加所謂的bootstrap script - 就是我們只要執行那個檔案，而那個檔案會把該做的都設定好。幫我們防呆。 </p><p>所以，我會建立另外一個檔案，我叫做<code>build.ps1</code>，用作於每一次建制的時候執行。 </p><p>裡面有的內容如下： </p><pre class="brush: powershell;"><code class="language-powershell line-numbers">  # 如果psake module有存在，先把他反註解
if (Get-Module -ListAvailable -Name psake) {
 Remove-Module psake
} 

# 找到psake module並且註冊
$psakeModulePath = (Get-ChildItem("..\packages\psake*\tools\psake.psm1")).FullName |
     Sort-Object $_ | select -Last 1

if(Test-Path $psakeModulePath){
 Import-Module $psakeModulePath
}else{
 Write-Host "找不到psake module，請確認好nuget package有restore完成"
 return
}

# 執行psake
Invoke-psake -buildFile .\default.ps1 -taskList Test `
    -properties @@{
    "testMsg"="測試訊息"
    }
  </code></pre><figure><a href="https://lh3.googleusercontent.com/-qF-Fvfa4UB8/WEQZjz7abvI/AAAAAAAAU9k/Keni4EATw2g/s1600-h/image%25255B17%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="/posts/migrate/2016-12-04-devopsSeries-psakeIntro_Asset/image_thumb[5](2).png" width="644" height="452" class="img-responsive"></a><figcaption>執行變得簡單，只要呼叫build.ps1</figcaption></figure></section><section> <h2 id="WizKMOutline_1480857627522997">結語</h2><p>希望透過這篇，對於psake如何定義和使用有了基本的概念。我們將會在接下來使用這個專案建制我們的build script。 </p><p>在下篇，我們將會開始進入建制的部分，psake如何利用現有MSBuild有的資源作出我們要的建制環境。 </p></section>