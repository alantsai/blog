Title: "[iThome第8屆鐵人賽 17]OpenCover 結果 - 涵蓋率介紹篇"
Published: 2017-01-14
Modified: 2017-12-12
Image: /posts/migrate/2017-01-14-devopsSeries-opencover-coverageMetrixsExplained_Asset/image_thumb(13).png
Tags: [".net","「ithome 第八屆鐵人賽」","devops","「從.net工程師的角度來看devops」"]
RedirectFrom: 2017/01/devopsSeries-opencover-coverageMetrixsExplained.html
Series: ["「iThome 第八屆鐵人賽」","「從.Net工程師的角度來看DevOps」"]
---
<section> <p>在上篇把OpenCover整合到測試之後，每當執行測試後會產生出一個涵蓋率的結果報告出來。 </p><p>這個涵蓋率的結果是一個xml的檔案，這個xml其實有非常豐富的資訊，但是沒有一些基礎概念會不理解是什麼意思。 </p><p>因此，在這篇，將會對於涵蓋率相關的資訊做一個介紹和說明。 </p></section><section><a id="KMContentPageTopID" name="KMContentPageTopID"></a> <div id="divKMOutline" style="border-top-style: groove; border-bottom-style: groove; border-right-style: none; margin: 10px 0px; border-left-style: none"><ul style="margin: 0px 0px 0px 20px"><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484383727619360" ;="">涵蓋率到底怎麼計算</a><br><ul style="margin: 0px 0px 0px 30px"><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484383727619189" ;="">Line Coverage</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484383727619885" ;="">Statement Coverage</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484383727619584" ;="">Sequence Point Coverage</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484383727619517" ;="">Branch Coverage</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484383727619754" ;="">為什麼要有Branch Coverage</a></li><br></ul></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484383727619419" ;="">Open Cover支援的計算方式</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484383727619492" ;="">看Open Cover執行完的結果</a><br></li><li><a style="font-size: 14pt; line-height: 1.5" href="#WizKMOutline_1484383727619340" ;="">結語</a></li><br></ul></div></section> <a name="more"></a><section> <h2 id="WizKMOutline_1484383727619360">涵蓋率到底怎麼計算</h2><p>涵蓋率其實有非常多種算法，其中常見的有： </p><ul><li><em>Class Coverage</em> - 當一個class有被測試到，那麼就算1個測試點<br></li><li><em>Method Coverage</em> - 當方法有被測試到，就算，<em>不管</em>是不是所有方法的執行路徑都有被測試到，都算一個測試點<br></li><li><em>Line Coverage</em> - 每一行算1個測試點<br></li><li><em>Statement Coverage</em> - 每一個statement算是1個測試點<br></li><li><em>Sequence Point Coverage</em> - 每一個可以被中斷的地方都是1個測試點<br></li><li><em>Branch Coverage</em> - 每一個分叉點（不管那個分叉多少程式碼）都算1點 </li><br></ul><p>以上就是常見的涵蓋率計算方式，其中1和2（class 和 method）比較算是一個總覽，更多在看的是3之後的方法。 </p><p>不過，3之後的算法，只靠這幾個說明文字可能不容易理解，所以來看一下例子。 </p><h3 id="WizKMOutline_1484383727619189">Line Coverage</h3><p>Line Coverage 可以說是最基本的涵蓋率算法，概念很簡單，就是每一行算一個測試點，換句話說： </p><figure><a href="https://lh3.googleusercontent.com/-wigOd7C4mCQ/WHnnV6nBbaI/AAAAAAAAVHU/SDBhg4Iz5_w/s1600-h/image%25255B2%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="/posts/migrate/2017-01-14-devopsSeries-opencover-coverageMetrixsExplained_Asset/image_thumb(13).png" width="507" height="256" class="img-responsive"></a><figcaption>以這個例子來說，就是總共有4個測試點</figcaption></figure>  <p>可以發現，測試點比較粗糙，第3點和第4點都只個算1點而已。 </p><h3 id="WizKMOutline_1484383727619885">Statement Coverage</h3><p>Statement Coverage比Line Coverage好一點，它是以每一個statement算一個點，所以： </p><figure><a href="https://lh3.googleusercontent.com/-Rp43HXh_FWs/WHnnXw8gLLI/AAAAAAAAVHc/aMRDyLB0XH0/s1600-h/image%25255B5%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="/posts/migrate/2017-01-14-devopsSeries-opencover-coverageMetrixsExplained_Asset/image_thumb[1](12).png" width="507" height="256" class="img-responsive"></a><figcaption>可以看到同樣一個程式碼，有5個測試點</figcaption></figure>  <h3 id="WizKMOutline_1484383727619584">Sequence Point Coverage</h3><p>Statement Coverage不錯，但是畢竟一個statement不代表只有一種可能，因此又有了Sequence Point Coverage。這種coverage的概念是，只要能夠放<em>中斷點</em>的都算1點測試點： </p><figure><a href="https://lh3.googleusercontent.com/-iFDxK5vqHZ4/WHnnfj8InkI/AAAAAAAAVHk/jxIXNfYBReA/s1600-h/image%25255B8%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="/posts/migrate/2017-01-14-devopsSeries-opencover-coverageMetrixsExplained_Asset/image_thumb[2](6).png" width="507" height="256" class="img-responsive"></a><figcaption>同一個程式碼，變成了7個測試點</figcaption></figure>  <h3 id="WizKMOutline_1484383727619517">Branch Coverage</h3><p>每一個分叉點算1個測試點，舉例來說： </p><figure><a href="https://lh3.googleusercontent.com/-7LHGgsav9o0/WHnnipD408I/AAAAAAAAVHs/fILu0todb4c/s1600-h/image%25255B11%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="/posts/migrate/2017-01-14-devopsSeries-opencover-coverageMetrixsExplained_Asset/image_thumb[3](6).png" width="307" height="365" class="img-responsive"></a><figcaption>總共3個分叉點，所以3個</figcaption></figure>  <h3 id="WizKMOutline_1484383727619754">為什麼要有Branch Coverage</h3><p>或許會覺得為什麼需要Branch Coverage？原因很簡單，因為Branch Coverage是用來輔助呈現一個方法的分叉點是否都有測試到。 </p><p>這個其實是用來輔助Sequence Point Coverage，可以想象一下，如果你在if裡面有兩行，在Sequence Point算兩點，如果有10行，會算10點，當if裡面行數越多，點數越多，會<em>沖淡掉</em> 最後百分比的數值。 </p><p>這個時候Branch Coverage變得很方便，因為整個if只算1點，要嗎過，要嗎不過。 </p></section><section> <h2 id="WizKMOutline_1484383727619419">Open Cover支援的計算方式</h2><p>上面介紹完了計算方法之後，可以看的出來，Line Coverage 和 Statement Coverage其實沒有那麼準確，Sequence Point反而是比較精準的計算方式。而Sequence point在看方法的路徑是不是都有涵蓋到 的時候不容易看，這個時候Branch Coverage就很適合。 </p><p>因此，Open Cover的結果包含了： </p><ol><li>Class Coverage<br></li><li>Method Coverage<br></li><li>Sequence Point Coverage<br></li><li>Branch Coverage</li><br></ol></section><section> <h2 id="WizKMOutline_1484383727619492">看Open Cover執行完的結果</h2><p>有了上面的概念之後，再來看一下open cover產生的結果： </p><figure><a href="https://lh3.googleusercontent.com/-CzYewR_ldEY/WHnnnDTpeOI/AAAAAAAAVH0/LS-yGR-G6h8/s1600-h/image%25255B14%25255D.png"><img title="image" style="border-top: 0px; border-right: 0px; background-image: none; border-bottom: 0px; padding-top: 0px; padding-left: 0px; margin: 0px; border-left: 0px; display: inline; padding-right: 0px" border="0" alt="image" src="/posts/migrate/2017-01-14-devopsSeries-opencover-coverageMetrixsExplained_Asset/image_thumb[4](5).png" width="501" height="328" class="img-responsive"></a><figcaption>可以看到，上面提到的4個Coverage資訊都有</figcaption></figure></section><section>  <h2 id="WizKMOutline_1484383727619340">結語</h2><p>了解了Coverage的算法之後，其實就可以parse這個xml結果並且把內容呈現出來（題外話：在Powershell裡面處理xml其實非常方便）。 </p><p>甚至可以做到說，當某個Coverage的百分比數低於某個值的時候，不讓建制成功 - 不過這個部分在這邊不會做這個事情，有興趣可以利用Powershell處理xml的方法把內容parse出來在做判斷。 </p><p>但是，最後要使用者來看這個xml來了解情況實在不方便，況且也沒有辦法容易看出到底是那裡沒有cover到。 </p><p>因此，下篇將會介紹，有什麼方式可以讓結果更user friendly。 </p></section>